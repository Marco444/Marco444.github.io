{"version":3,"sources":["visualiser/components/Welcome.js","visualiser/model/utils.js","visualiser/model/animations/AnimationsEngine.js","visualiser/components/Canvas.js","visualiser/components/buttons/SortButton.js","visualiser/components/buttons/ShuffleButton.js","visualiser/components/buttons/FunctionsButtons.js","visualiser/components/radioBox/AlgorithmSelector.js","visualiser/components/sliders/SliderAnimationSpeed.js","visualiser/model/algorithms/mergeSort.js","visualiser/model/algorithms/quickSort.js","visualiser/model/algorithms/SortingAlgorithm.js","visualiser/model/algorithms/radixSort.js","visualiser/model/algorithms/bubbleSort.js","visualiser/model/algorithms/selectionSort.js","visualiser/model/algorithms/insertionSort.js","visualiser/model/algorithms/heapSort.js","visualiser/components/InformationBox.js","visualiser/components/sliders/SliderNumberBars.js","App.js","visualiser/components/tutorial/FunctionButtonTutorial.js","visualiser/components/tutorial/AlgorithmSelectorExplanation.js","visualiser/components/tutorial/SlidersExplanation.js","visualiser/components/tutorial/InformationBoxExplanation.js","visualiser/components/tutorial/Tutorial.js","MainApp.js","index.js"],"names":["buttonStyle","color","backgroundColor","WelcomeGuide","display","close","width","height","startTutorial","widthBox","heightBox","Modal","open","onClose","Box","sx","marginLeft","marginTop","padding","Typography","fontSize","fontWeight","paddingTop","Stack","direction","Button","onClick","style","newShuffledArray","length","minValue","maxValue","min","max","array","i","push","Math","floor","random","swap","j","temp","SwapAnimation","current","next","auxWidth","begin","CopyAnimation","newWidth","this","defaultBarColor","sortedColor","AnimationType","duration","defaultColor","animate","AlgorithmSelection","SliderSelection","Sorted","Shuffle","Animation","type","apply","animateBarsWith","animation","animationsSet","getSortedAnimations","addSwapAnimation","setAnimations","addCopyAnimation","auxiliaryArray","Canvas","position","props","canvasWidth","marginRight","map","value","idx","className","barsHeight","Component","SortButton","isBusy","sortButtonClicked","disabled","bgcolor","paddingLeft","ShuffleButton","shuffleButtonClicked","FunctionsButtons","ButtonGroup","orientation","variant","AlgorithmSelector","stackWidth","mergeSortButtonClicked","bubbleSortButtonClicked","quickSortButtonClicked","radixSortButtonClicked","selectionSortButtonClicked","insertionSortButtonClicked","labelSX","heapSortButtonClicked","FormControl","component","RadioGroup","defaultValue","name","paddingBottom","id","alignItems","flexWrap","gutterBottom","FormControlLabel","control","Radio","label","onChange","SliderAnimationSpeed","maxSliderSpeedValue","minSliderSpeedValue","defaultSpeedValue","sliderWidth","handleSpeedSlider","Slider","marginBottom","getMergeSortAnimations","animations","slice","mergeSort","concat","mainArray","left","right","middle","k","merge","getQuickSortAnimations","quickSort","p","pivot","partition","SortingAlgorithm","text","complexity","radixSort","idx1","idx2","idx3","len1","radix","radixKey","curr","currLen","currBucket","radices","buckets","toString","hasOwnProperty","getRadixSortAnimations","bubbleSort","getBubbleSortAnimations","selectionSort","start","smallest","getSelectionSortAnimations","insertionSort","getInsertionSortAnimations","heapSort","none","InformationBox","algorithm","useState","slide","setSlide","useEffect","float","SliderNumberBars","maxNumberBars","minNumberBars","defaultNumberBars","handlerBarsNumberSlider","App","canvasHeight","stackHeight","functionButtonsHeight","algorithmBoxHeight","slidersHeight","isMobileDevice","ANIMATION_SPEED_SLIDER_MAX","sortingAnimationSpeed","setSortingAnimationSpeed","animationSpeed","numberOfBars","setNumberOfBars","barsLength","setBusy","setArray","sortingAlgorithm","setSortingAlgorithm","defaultNumberOfBars","defaultAnimationSpeed","applyAnimations","getSelectedAnimations","getShuffleAnimations","getAlgorithmSelectionAnimation","speed","index","setTimeout","currentBars","document","getElementsByClassName","applyTo","m","bind","getAnimations","event","FunctionButtonTutorial","explanationBoxStyle","textStyleTutorial","buttonStyleTutorial","AlgorithmSelectorExplanation","SlidersExplanation","InformationBoxExplanation","margin","Tutorial","stackTopLeftMargin","setCurrent","tutorialSteps","prev","controllersLeftTopMargin","MainApp","useWindowSize","welcome","showWelcome","setStartTutorial","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b254a358.chunk.js","sourcesContent":["import {Box, Modal, Stack, Typography} from \"@mui/material\";\nimport Button from \"@mui/material/Button\";\nimport CloseIcon from '@mui/icons-material/Close';\n\nconst buttonStyle = {\n    color: '#fff',\n    '&:hover': {\n        backgroundColor: '#fff',\n        color: '#3c52b2',\n    },\n}\n\n/**\n * Designed as a modal to allow the user to select whether they want a tutorial of how the app works\n * **/\n\nexport const WelcomeGuide = ({display, close, width, height, startTutorial}) => {\n    const a = 1\n    const widthBox = width / 4\n    const heightBox = height / 4\n\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Box sx={{\n                backgroundColor: 'rgba(0,43,162,0.98)',\n                width: widthBox,\n                height: heightBox,\n                marginLeft: width / 20 - widthBox / 50,\n                marginTop: height / 20 - heightBox / 50,\n                padding: 3,\n            }}>\n                <Typography sx={{\n                    fontSize: 40,\n                    color: 'white',\n                    fontWeight: 'bold',\n                }}>\n                    Welcome,\n                </Typography>\n                <Typography sx={{\n                    color: 'white',\n                    fontWeight: 'bold',\n                    paddingTop: 2\n                }}>\n                    This is a small app made in React designed to visualise sorting algorithms\n                </Typography>\n\n                <Stack direction='row' sx={{paddingTop: 7}}>\n                    <Button onClick={close} sx={buttonStyle}> CLOSE </Button>\n                    <Button onClick={startTutorial}\n                            sx={buttonStyle} style={{marginLeft: widthBox / 1.7}}> TUTORIAL</Button>\n                </Stack>\n\n            </Box>\n        </Modal>\n    );\n};","\nexport function newShuffledArray(length, minValue, maxValue) {\n    const array = [];\n    for (let i = 0; i <= length; i++) {\n        array.push(randomIntFromInterval(minValue, maxValue));\n    }\n    return array;\n}\n\nexport function randomIntFromInterval(min, max) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport function equalArrays(array1, array2) {\n    if (array1.length !== array2.length) return false;\n    for (let i = 0; i < array1.length; i++)\n        if (array1[i] !== array2[i])\n            return false;\n    return true;\n}\n\nexport function swap(i, j, array) {\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}","\n/****\n ***\n * This file was designed with the intent of storing the two types of aninmations we use in the sorting algorithms\n * (swapping and copying), and a ColorAnimation used for the ux experience.\n ***\n ****/\n\nclass SwapAnimation {\n    static begin = new SwapAnimation();\n    static end;\n\n    apply(current, next) {\n        const auxWidth = next.style.width\n        next.style.width = current.style.width\n        current.style.width = auxWidth\n    }\n}\n\nexport class CopyAnimation {\n\n    constructor(newWidth) {\n        this.newWidth = newWidth\n    }\n\n    apply(current) {\n        current.style.width = `${this.newWidth}px`\n    }\n}\n\n\nconst defaultBarColor = \"#47118f\"\nconst algorithmSelectedColor = \"#ffb4a1\"\nconst selectedColor = \"#21e892\"\nconst sortedColor = \"#e73068\"\n\nexport class AnimationType {\n\n    static AlgorithmSelection = new AnimationType(800, algorithmSelectedColor, defaultBarColor)\n    static SliderSelection = new AnimationType(800, selectedColor, defaultBarColor)\n    static Sorted = new AnimationType(800, sortedColor, defaultBarColor)\n    static Shuffle = new AnimationType(800, sortedColor, defaultBarColor)\n\n    constructor(duration, color, defaultColor) {\n        this.duration = duration\n        this.color = color\n        this.defaultColor = defaultColor\n    }\n\n\n    apply(current, next) {\n        current.animate(\n            {backgroundColor: [this.color, this.defaultColor]}\n            , this.duration)\n\n        next.animate(\n            {backgroundColor: [this.color, this.defaultColor]}\n            , this.duration)\n    }\n}\n\nexport class Animation {\n\n    constructor(type, i, j) {\n        this.type = type;\n        this.i = i;\n        this.j = j;\n    }\n\n    applyTo(array) {\n        this.type.apply(array[this.i], array[this.j])\n    }\n\n}\n\n/*\n* Takes an array of elements and a type of animation and returns\n* a list of applying that animation to every element in the array\n* */\nfunction animateBarsWith(array, animation) {\n    let animationsSet = []\n\n    for(let i = 0; i < array.length; i++)\n        animationsSet.push(new Animation(animation, i, i))\n\n    return animationsSet\n}\n\n///////////////////////////////////////////////////////\n//// Functions to provide different animations ////////\n///////////////////////////////////////////////////////\n\nexport function getSortedAnimations(array) {\n   return animateBarsWith(array, AnimationType.Sorted)\n}\n\nexport function getShuffleAnimations(array) {\n  return animateBarsWith(array, AnimationType.Shuffle)\n}\n\nexport function getSelectedAnimations(array) {\n   return animateBarsWith(array, AnimationType.SliderSelection)\n}\n\nexport function getAlgorithmSelectionAnimation(array) {\n    return animateBarsWith(array, AnimationType.AlgorithmSelection)\n}\n\nexport function addSwapAnimation(i, j, setAnimations) {\n    setAnimations.push(new Animation(AnimationType.SliderSelection, i, j))\n    setAnimations.push(new Animation(SwapAnimation.begin, i, j))\n}\n\nexport function addCopyAnimation(i, j, setAnimations, auxiliaryArray) {\n    setAnimations.push(new Animation(AnimationType.SliderSelection, i, j))\n    setAnimations.push(new Animation(new CopyAnimation(auxiliaryArray[i]), j))\n}\n","import React, {Component} from \"react\";\nimport {Box} from \"@mui/material\";\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = '#47118f';\nconst CANVAS_COLOR = '#ffc5b6'\n\n/**\n * Designed to host all of the bars, it maps each of the values of the array received as props to a new\n * div whose width depends to that array element's value and whose height is determined by the app.\n * **/\nexport default class Canvas extends Component {\n\n    render() {\n        return (\n            <Box sx={{\n                position: 'relative',\n                height: this.props.height / 1.1,\n                width: this.props.canvasWidth,\n                backgroundColor: CANVAS_COLOR,\n                marginLeft: 2,\n                marginRight: 2\n            }}>\n                {this.props.array.map((value, idx) => (\n                    <div key={idx} className=\"arrayBar\" style={{\n                        width: `${value}px`,\n                        height: `${this.props.barsHeight}px`,\n                        backgroundColor: PRIMARY_COLOR\n                    }}> </div>\n                ))}\n            </Box>\n        );\n    }\n}\n","import PlayCircleOutlineRoundedIcon from \"@mui/icons-material/PlayCircleOutlineRounded\";\nimport Button from \"@mui/material/Button\";\nimport React from \"react\";\n\nexport const SortButton = ({isBusy, sortButtonClicked, height}) => {\n   return (\n       <Button key=\"one\" disabled={isBusy}\n               sx={{\n                   bgcolor: '#234ebe',\n                   color: 'white',\n                   fontWeight: 'bold',\n                   paddingLeft: 2,\n                   paddingTop: 1,\n                   height: height\n               }} onClick={sortButtonClicked}> SORT\n           <PlayCircleOutlineRoundedIcon sx={{paddingLeft: 1}}/>\n       </Button>\n   );\n}","import Button from \"@mui/material/Button\";\nimport ShuffleOnRoundedIcon from \"@mui/icons-material/ShuffleOnRounded\";\nimport React from \"react\";\n\nexport const ShuffleButton = ({isBusy, shuffleButtonClicked, height}) => {\n    return (\n        <Button key=\"two\" disabled={isBusy}\n                sx={{\n                    bgcolor: '#ff518a',\n                    color: 'white',\n                    fontWeight: 'bold',\n                    paddingLeft: 2,\n                    paddingTop: 1,\n                    height: height\n                }} onClick={shuffleButtonClicked}> SHUFFLE\n            <ShuffleOnRoundedIcon sx={{paddingLeft: 1}} />\n        </Button>\n    );\n}","import {SortButton} from \"./SortButton\";\nimport {ShuffleButton} from \"./ShuffleButton\";\nimport ButtonGroup from \"@mui/material/ButtonGroup\";\nimport React from \"react\";\nimport {Box, Modal, Slide} from \"@mui/material\";\n\n/**\n * Designed to hold functionality of sort and shuffle\n * **/\n\nexport const FunctionsButtons = ({isBusy, sortButtonClicked, shuffleButtonClicked, height}) => {\n\n    return (\n        <ButtonGroup\n            orientation=\"vertical\"\n            aria-label=\"vertical contained button group\"\n            variant=\"contained\" sx={{height: height}}>\n            <SortButton height={height / 2} isBusy={isBusy} sortButtonClicked={sortButtonClicked}/>\n            <ShuffleButton height={height / 2} isBusy={isBusy} shuffleButtonClicked={shuffleButtonClicked}/>\n        </ButtonGroup>\n    );\n}","import {FormControl, FormControlLabel, Radio, RadioGroup, Stack, Typography} from \"@mui/material\";\nimport SortRoundedIcon from \"@mui/icons-material/SortRounded\";\nimport React from \"react\";\n\n/**\n * Design to allow the user to select which algorithm they want to see visualised,\n * when clicked each buttons calls the respective callback defined in App.js\n * **/\n\nexport const AlgorithmSelector = ({\n                                      stackWidth, mergeSortButtonClicked, bubbleSortButtonClicked,\n                                      isBusy, quickSortButtonClicked, radixSortButtonClicked,\n                                      selectionSortButtonClicked, insertionSortButtonClicked, heapSortButtonClicked,\n                                  }) => {\n    const labelSX = {\n        padding: 1\n    }\n\n    return (\n\n        <FormControl sx={{\n            marginTop: 1,\n            fontWeight: 'bold',\n            color: 'white',\n            width: stackWidth,\n        }} component=\"fieldset\">\n\n            <RadioGroup\n                aria-label=\"gender\"\n                defaultValue=\"female\"\n                name=\"radio-controllers-group\"\n                sx={{\n                    bgcolor: '#ffb4a1',\n                    color: 'white',\n                    paddingLeft: 2,\n                    paddingTop: 2,\n                    paddingBottom: 2,\n                    fontWeight: 'bold',\n                }}>\n                <Typography id=\"animation-slider\" sx={{\n                    fontWeight: 'bold',\n                    display: 'flex',\n                    alignItems: 'center',\n                    flexWrap: 'wrap',\n                }} gutterBottom> Algorithms\n                    <SortRoundedIcon sx={{paddingLeft: 1}}/>\n                </Typography>\n                <Stack sx={{fontWeight: 'bold'}}>\n                    <FormControlLabel sx={labelSX} value=\"selectionSort\" control={<Radio/>} label=\"Selection Sort\"\n                                      onChange={selectionSortButtonClicked} disabled={isBusy}>\n                    </FormControlLabel>\n\n                    <FormControlLabel sx={labelSX} value=\"insertionSort\" control={<Radio/>} label=\"Insertion Sort\"\n                                      onChange={insertionSortButtonClicked} disabled={isBusy}/>\n\n                    <FormControlLabel sx={labelSX} value=\"bubbleSort\" control={<Radio/>} label=\"Bubble Sort\"\n                                      onChange={bubbleSortButtonClicked} disabled={isBusy}/>\n\n                    {/*<FormControlLabel sx={labelSX} value=\"heapSort\" control={<Radio/>} label=\"Heap Sort\"\n                                      onChange={heapSortButtonClicked} disabled={isBusy}/>*/}\n\n                    <FormControlLabel sx={labelSX} value=\"mergeSort\" control={<Radio/>} label=\"Merge Sort\"\n                                      onChange={mergeSortButtonClicked} disabled={isBusy}/>\n\n                    <FormControlLabel sx={labelSX} value=\"quickSort\" control={<Radio/>} label=\"Quick Sort\"\n                                      onChange={quickSortButtonClicked} disabled={isBusy}/>\n\n                    <FormControlLabel sx={labelSX} value=\"radixSort\" control={<Radio/>} label=\"Radix Sort\"\n                                      onChange={radixSortButtonClicked} disabled={isBusy}/>\n                </Stack>\n            </RadioGroup>\n        </FormControl>\n\n\n    );\n}","import {Slider, Stack, Typography} from \"@mui/material\";\nimport SpeedRoundedIcon from \"@mui/icons-material/SpeedRounded\";\nimport React from \"react\";\n\n/**\n * Designed to allow the user to modify the speed of the animations as they happen when the\n * sort button is clicked\n * **/\n\nexport const SliderAnimationSpeed = ({maxSliderSpeedValue, minSliderSpeedValue, defaultSpeedValue,\n                                         sliderWidth, handleSpeedSlider, isBusy, height, marginTop}) => {\n    return (\n        <Stack sx={{\n            backgroundColor: 'rgba(57,92,183,0.98)',\n            marginTop: 1,\n            color: \"white\",\n        }}>\n            <Stack>\n                <Typography id=\"animation-slider\" sx={{\n                    paddingTop: 2,\n                    paddingLeft: 2,\n                    fontWeight: 'bold',\n                    display: 'flex',\n                    alignItems: 'center',\n                    flexWrap: 'wrap',\n                }}> Animation Speed\n                    <SpeedRoundedIcon sx={{paddingLeft: 1}}/>\n                </Typography>\n            </Stack>\n            <Slider max={maxSliderSpeedValue} min={minSliderSpeedValue}\n                    defaultValue={defaultSpeedValue} key={1} sx={{\n                marginLeft: 2,\n                marginBottom: 2,\n                width: sliderWidth * 0.825\n            }} onChange={handleSpeedSlider} disabled={isBusy}/>\n        </Stack>\n    );\n}","import {addCopyAnimation} from \"../animations/AnimationsEngine\"\nimport {getSortedAnimations} from \"../animations/AnimationsEngine\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const mergeSortInfo =\n    `    Merge Sort works by recursively dividing the list of elements in half\n        until it can't anymore. Then it merges all the subarrays, maintaining the correct\n        order of the elements, until we dont have more subarrays to merge. \n        \n        Like Quick Sort, merge sort is a divide and conquer algorithm. These algorithms work\n        by dividing the input based on a heuristic (in this case by half, but can be in even \n        and odd for example). Then solves each of the sub-problems, and finally merges all of\n        them together.`\n\nexport const mergeSortComplexity =\n    `\n        In terms of time complexity its best, worst and average cases are all O(n*logn), while \n        space complexity is at worst linear.\n    `\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getMergeSortAnimations(array) {\n    const animations = [];\n    const auxiliaryArray = array.slice();\n\n    mergeSort(array, 0, array.length - 1, auxiliaryArray, animations);\n\n    return animations.concat(getSortedAnimations(array));\n}\n\nfunction mergeSort(mainArray, left, right, auxiliaryArray, animations,) {\n    if (left === right) return;\n    const middle = Math.floor((left + right) / 2);\n    mergeSort(auxiliaryArray, left, middle, mainArray, animations);\n    mergeSort(auxiliaryArray, middle + 1, right, mainArray, animations);\n    merge(mainArray, left, middle, right, auxiliaryArray, animations);\n}\n\nfunction merge(mainArray, left, middle, right, auxiliaryArray, animations) {\n    let k = left;\n    let i = left;\n    let j = middle + 1;\n\n\n    while (i <= middle && j <= right) {\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            addCopyAnimation(i, k, animations, auxiliaryArray)\n            mainArray[k++] = auxiliaryArray[i++];\n\n        } else {\n            addCopyAnimation(j, k, animations, auxiliaryArray)\n            mainArray[k++] = auxiliaryArray[j++];\n        }\n    }\n\n    while (i <= middle) {\n        addCopyAnimation(i, k, animations, auxiliaryArray)\n        mainArray[k++] = auxiliaryArray[i++];\n    }\n\n    while (j <= right) {\n        addCopyAnimation(j, k, animations, auxiliaryArray)\n        mainArray[k++] = auxiliaryArray[j++];\n    }\n}\n","import {addSwapAnimation} from \"../animations/AnimationsEngine\";\nimport {getSortedAnimations} from \"../animations/AnimationsEngine\";\nimport {swap} from \"../utils\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const quickSortInfo =\n    `     Quick Sort works by recursively partitioning the list of elements based upon a pivot element and then sorting\n       each subarray recursively by putting the pivot in the correct order. \n       \n       It works similarly to Merge Sort because both are divide and conquer algorithms.Their differences being how they\n       divide into subproblems and how they merge.`\n\nexport const quickSortComplexity =\n    `\n        In terms of time complexity its average case is O(n*logn), worst case is O(n^2), and best is O(n*logn), while\n        space complexity is at worst linear.\n    `\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getQuickSortAnimations(array) {\n    let animations = []\n\n    quickSort(animations, array, 0, array.length - 1)\n\n    return animations.concat(getSortedAnimations(array))\n}\n\nfunction quickSort(animations, array, left, right) {\n    if (left < right) {\n        let p = partition(animations, array, left, right)\n        quickSort(animations, array, left, p - 1)\n        quickSort(animations, array, p + 1, right)\n    }\n}\n\nfunction partition(animations, array, left, right) {\n\n    let pivot = array[right]\n    let i = left - 1\n\n    for (let j = left; j <= right - 1; j++) {\n        if (array[j] < pivot) {\n            i++;\n\n            addSwapAnimation(i, j, animations)\n            swap(i, j, array)\n        }\n    }\n\n    addSwapAnimation(i + 1, right, animations)\n    swap(i + 1, right, array)\n\n\n    return i + 1\n}\n\n","import getMergeSortAnimations, {mergeSortComplexity, mergeSortInfo} from \"./mergeSort\";\nimport getQuickSortAnimations, {quickSortComplexity, quickSortInfo} from \"./quickSort\";\nimport getRadixSortAnimations, {radixSortComplexity, radixSortInfo} from \"./radixSort\";\nimport getBubbleSortAnimations, {bubbleSortComplexity, bubbleSortInfo} from \"./bubbleSort\";\nimport getSelectionSortAnimations, {selectionSortComplexity, selectionSortInfo} from \"./selectionSort\";\nimport getInsertionSortAnimations, {insertionSortComplexity, insertionSortInfo} from \"./insertionSort\";\nimport getHeapSortAnimations, {heapSortComplexity, heapSortInfo} from \"./heapSort\";\n\n\n/**\n * Designed to encapsulate all the different sorting algorithms into a kind of enum (came from coding a lot in java),\n * such that we can directly update the current algorithm in App.js to one of these enum values, and call methods from it\n * and get different functionality for the same method calls given the current algorithm selected\n * **/\n\nexport class SortingAlgorithm {\n\n    static mergeSort = new SortingAlgorithm(mergeSortInfo, mergeSortComplexity, (array) => getMergeSortAnimations(array))\n    static quickSort = new SortingAlgorithm(quickSortInfo, quickSortComplexity, (array) => getQuickSortAnimations(array))\n    static radixSort = new SortingAlgorithm(radixSortInfo, radixSortComplexity, (array) => getRadixSortAnimations(array))\n    static bubbleSort = new SortingAlgorithm(bubbleSortInfo, bubbleSortComplexity, (array) => getBubbleSortAnimations(array))\n    static selectionSort = new SortingAlgorithm(selectionSortInfo, selectionSortComplexity, (array) => getSelectionSortAnimations(array))\n    static insertionSort = new SortingAlgorithm(insertionSortInfo, insertionSortComplexity, (array) => getInsertionSortAnimations(array))\n    static heapSort = new SortingAlgorithm(heapSortInfo, heapSortComplexity, (array) => getHeapSortAnimations(array),)\n    static none = new SortingAlgorithm(\"\", \"\", () => ([]),)\n\n    constructor(text, complexity, animations) {\n        this.text = text\n        this.animations = animations\n        this.complexity = complexity\n    }\n\n    getAnimations(array) {\n        return this.animations(array)\n    }\n\n}\n\n","import {\n    Animation,\n    AnimationType,\n    CopyAnimation,\n    getSortedAnimations\n} from \"../animations/AnimationsEngine\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const radixSortInfo =\n    `   Radix Sort works by  creating and distributing elements into buckets according to their radix.\n        For elements with more than one significant digit, this bucketing process is repeated for each digit,\n        while preserving the ordering of the prior step, until all digits have been considered.\n    `\n\nexport const radixSortComplexity =\n    `\n        In terms of time complexity its O(n) with the requirement that they are in the range 1 to n^c with c being a constant\n        \n        This means that for most numbers  we have linear complexity, the lower bound for any sorting algorithm! (we need\n        to at least traverse every element to know how to order them) .\n    `\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getRadixSortAnimations(array) {\n    let animations = []\n\n    let idx1, idx2, idx3, len1, len2, radix, radixKey;\n    let radices = {}, buckets = {}, num, curr;\n    let currLen, radixStr, currBucket;\n\n    len1 = array.length;\n    len2 = 10;  // radix sort uses ten buckets\n\n    // find the relevant radices to process for efficiency\n    for (idx1 = 0;idx1 < len1;idx1++) {\n        radices[array[idx1].toString().length] = 0;\n    }\n\n    // loop for each radix. For each radix we put all the items\n    // in buckets, and then pull them out of the buckets.\n    for (radix in radices) {\n        // put each array item in a bucket based on its radix value\n        len1 = array.length;\n        for (idx1 = 0;idx1 < len1;idx1++) {\n            curr = array[idx1];\n            // item length is used to find its current radix value\n            currLen = curr.toString().length;\n            // only put the item in a radix bucket if the item\n            // key is as long as the radix\n            if (currLen >= radix) {\n                // radix starts from beginning of key, so need to\n                // adjust to get redix values from start of stringified key\n                radixKey = curr.toString()[currLen - radix];\n                // create the bucket if it does not already exist\n                if (!buckets.hasOwnProperty(radixKey)) {\n                    buckets[radixKey] = [];\n                }\n                // put the array value in the bucket\n                buckets[radixKey].push(curr);\n            } else {\n                if (!buckets.hasOwnProperty('0')) {\n                    buckets['0'] = [];\n                }\n                buckets['0'].push(curr);\n            }\n        }\n\n        // for current radix, items are in buckets, now put them\n        // back in the array based on their buckets\n        // this index moves us through the array as we insert items\n        idx1 = 0;\n\n        // go through all the buckets\n        for (idx2 = 0;idx2 < len2;idx2++) {\n            // only process buckets with items\n            if (buckets[idx2] != null) {\n                currBucket = buckets[idx2];\n                // insert all bucket items into array\n                len1 = currBucket.length;\n                for (idx3 = 0;idx3 < len1;idx3++) {\n                    animations.push(new Animation(AnimationType.SliderSelection, idx1, idx1))\n                    animations.push(new Animation(new CopyAnimation(currBucket[idx3]), idx1))\n                    array[idx1++] = currBucket[idx3];\n                }\n            }\n        }\n        buckets = {};\n    }\n    \n    return animations.concat(...getSortedAnimations(array))\n}","import {addSwapAnimation, getSortedAnimations,} from \"../animations/AnimationsEngine\";\nimport {swap} from \"../utils\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const bubbleSortInfo =\n    `   Bubble sort works by traversing all the elements the amount of\n        times being equal to the number of elements, and\n        whenever two adjacent elements can be shifted in the\n        correct order, they are shifted.\n        \n        Its applications often involve places where memory is scarce\n        and the amount of elements isn't extremely big. Although within\n        cuadratic algorithms it's usually outperformed by insertion sort`\n\nexport const bubbleSortComplexity =\n    `\n        In terms of time complexity its average, worst and best case are all O(n^2),\n        while its space complexity is constant as its an in-place algorithm.\n    `\n\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getBubbleSortAnimations(array) {\n    let setAnimations = []\n\n    if (array.length === 0) return setAnimations;\n\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0; j < array.length - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n\n                addSwapAnimation(j, j + 1, setAnimations)\n                swap(j, j + 1, array)\n            }\n        }\n\n    }\n\n\n    return setAnimations.concat(getSortedAnimations(array))\n}\n","import {addSwapAnimation} from \"../animations/AnimationsEngine\";\nimport {swap} from \"../utils\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const selectionSortInfo =\n    `\n        Selection Sort works by traversing every element in the array, assuming its the smallest or biggest,\n        and then for every element to the right updating it so that it is the smallest or biggest of all the\n        elements to its right (in the unsorted array), then it swaps it into the index that it should have had\n        and continues until no more elements in the unsorted part are left. \n    `\n\nexport const selectionSortComplexity =\n    `\n        In terms of time complexity its best, average and worst case are all O(n^2), while its space complexity is constant. \n    `\n\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getSelectionSortAnimations(array) {\n\n    let animations = [];\n\n    let start = 0;\n    while(start < array.length - 1) {\n        let smallest = start;\n\n        for(let i = start + 1; i < array.length; i++){\n            if(array[smallest] > array[i]) smallest = i;\n        }\n\n        addSwapAnimation(start, smallest, animations)\n        swap(start, smallest, array);\n\n        start++;\n    }\n    return animations;\n}\n\n","import {swap} from \"../utils\";\nimport {addSwapAnimation} from \"../animations/AnimationsEngine\";\n\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const insertionSortInfo =\n    `\n    Insertion Sort works by traversing element in the array and putting it in the correct position, for \n    every element in the array, it swaps it with every other previous element until it's in the correct\n    position relative to the previous element.\n    \n    It is worth mentioning that of the cuadratic sorting family its usually the fastest.\n    `\nexport const insertionSortComplexity =\n    `\n        In terms of time complexity its best, average and worst case are all O(n^2), while its space complexity is constant. \n    `\n\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getInsertionSortAnimations(array) {\n    let animations = [];\n\n    for(let i = 1; i < array.length; i++) {\n        let j = i;\n        while(j > 0 && array[j] < array[j - 1]) {\n            swap(j, j - 1, array);\n            addSwapAnimation(j, j - 1, animations);\n            j -= 1;\n        }\n    }\n\n    return animations;\n}","\n/**\n * Information used in the components part once an algorithm is selected\n * **/\n\nexport const heapSortInfo =\n    `\n        Heap Sort works quite similarly to selection sort. It keeps an unsorted and a sorted region of the array,\n        and inserts every element from the unsorted region into their correct position in the sorted region. It differs\n        from selection sort in that it doesn't traverse all elements to know where it should be, but it pops it from\n        a heap to quickly find the element. Because of this its time complexity comes to be the same as the lower bound\n        for comparison-based sorts.\n    `\n\nexport const heapSortComplexity =\n    `\n        In terms of time complexity its best, average and worst case are all O(n*logn), while its space complexity is constant. \n       \n    `\n\n/**\n * Function same form for all the algorithms it takes an array and returns an array with the animations\n * corresponding to sorting the input array with the sorting algorithm\n * **/\n\nexport default function getHeapSortAnimations(array) {\n    return [];\n}","import {Box, Modal, Slide, Stack, Typography} from \"@mui/material\";\nimport React, {useEffect, useState} from \"react\";\nimport HelpOutlineIcon from '@mui/icons-material/HelpOutline';\nimport {SortingAlgorithm} from \"../model/algorithms/SortingAlgorithm\";\n\n\n/**\n * Designed to display the information of each the sorting algorithm selected, to achieve this it\n * listens to when the algorithm is changed, and updates its internal state to display the modal\n * with the corresponding algorithms information\n * **/\n\nexport const InformationBox = ({algorithm, width}) => {\n\n    const [slide, setSlide] = useState(false)\n\n    useEffect(() => {\n        setSlide(algorithm !== SortingAlgorithm.none)\n    }, [algorithm])\n\n\n    return (\n        <Modal\n            open={slide}\n            onClose={() => setSlide(false)}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack sx={{\n                width: width * 1.1,\n                backgroundColor:  \"#ff8181\",\n                marginTop: 3,\n                marginRight: 5,\n                color: \"white\",\n                float: \"right\"\n            }}>\n                <Box id=\"infog\" sx={{\n                    fontWeight: 'bold',\n                    display: 'flex',\n                    alignItems: 'center',\n                    flexWrap: 'wrap',\n                    padding: 2,\n                    paddingBottom: 0\n                }} gutterBottom> Information\n                    <HelpOutlineIcon sx={{paddingLeft: 1}} />\n\n                </Box>\n\n                <Typography sx={{padding: 2}}> {algorithm.text}  </Typography>\n                <Typography sx={{padding: 2, fontWeight: 'bold'}}> {algorithm.complexity}</Typography>\n            </Stack>\n        </Modal>\n    );\n}","import {Box, Slider, Stack} from \"@mui/material\";\nimport FormatLineSpacingIcon from \"@mui/icons-material/FormatLineSpacing\";\nimport React from \"react\";\n\n/**\n * Designed to allow the user to modify the number of the bars to be ordered\n * **/\n\n\nexport const SliderNumberBars = ({maxNumberBars, minNumberBars, defaultNumberBars,\n                                 sliderWidth, isBusy, handlerBarsNumberSlider}) => {\n   return (\n       <Stack sx={{\n           backgroundColor: 'rgba(57,92,183,0.98)',\n           marginTop: 1,\n           color: \"white\"\n       }}>\n           <Box id=\"bars-slider\" sx={{\n               paddingTop: 2,\n               paddingLeft: 2,\n               display: 'flex',\n               alignItems: 'center',\n               flexWrap: 'wrap',\n               fontWeight: 'bold',\n           }} gutterBottom> Number of bars\n               <FormatLineSpacingIcon sx={{paddingLeft: 1}} />\n           </Box>\n           <Slider max={maxNumberBars} min={minNumberBars}\n                   defaultValue={defaultNumberBars} id=\"sliderBars\" sx={{\n               marginLeft: 2,\n               marginBottom: 2,\n               width: sliderWidth * 0.825\n           }} onChange={handlerBarsNumberSlider} disabled={isBusy}/>\n       </Stack>\n   );\n}","import {newShuffledArray} from \"./visualiser/model/utils\";\nimport {\n    getAlgorithmSelectionAnimation,\n    getSelectedAnimations,\n    getShuffleAnimations\n} from \"./visualiser/model/animations/AnimationsEngine\";\n\nimport React, {useEffect, useState} from \"react\";\nimport {Stack} from \"@mui/material\";\nimport SortingVisualiser from \"./visualiser/components/Canvas\";\nimport {FunctionsButtons} from \"./visualiser/components/buttons/FunctionsButtons\";\nimport {AlgorithmSelector} from \"./visualiser/components/radioBox/AlgorithmSelector\";\nimport {SliderAnimationSpeed} from \"./visualiser/components/sliders/SliderAnimationSpeed\";\nimport {InformationBox} from \"./visualiser/components/InformationBox\";\nimport {SortingAlgorithm} from \"./visualiser/model/algorithms/SortingAlgorithm\";\nimport {SliderNumberBars} from \"./visualiser/components/sliders/SliderNumberBars\";\n\n\nexport const App = ({canvasHeight, canvasWidth, stackWidth, stackHeight, width, height,\n                    functionButtonsHeight, algorithmBoxHeight, slidersHeight, isMobileDevice}) => {\n\n    const ANIMATION_SPEED_SLIDER_MAX = 200;\n    const animationSpeed = 1\n    const barsHeight = animationSpeed * 2\n\n    const [sortingAnimationSpeed, setSortingAnimationSpeed] = useState(ANIMATION_SPEED_SLIDER_MAX * 0.25)\n    const [numberOfBars, setNumberOfBars] = useState(canvasHeight * 0.75 / barsHeight)\n    const barsLength = canvasWidth * 0.75\n\n    const [isBusy, setBusy] = useState(false)\n    const [array, setArray] = useState(newShuffledArray(numberOfBars, 0, barsLength))\n    const [sortingAlgorithm, setSortingAlgorithm] = useState(SortingAlgorithm.none)\n\n    const defaultNumberOfBars = numberOfBars\n    const defaultAnimationSpeed = sortingAnimationSpeed\n\n\n    const sortButtonClicked = () => {\n        setTimeout( () => {\n            if(sortingAlgorithm !== SortingAlgorithm.none)\n                setBusy(true)\n            applyAnimations(sortingAlgorithm.getAnimations(array), sortingAnimationSpeed)\n        }, 100)\n    }\n\n    const shuffleButtonClicked = () => {\n        setArray(newShuffledArray(numberOfBars, 0, barsLength))\n        setBusy(true)\n    }\n\n    const handleSpeedSlider = (event, value) => {\n        setBusy(true)\n        setSortingAnimationSpeed(() => ANIMATION_SPEED_SLIDER_MAX - value + 1)\n    }\n\n    const handleBarsNumberSlider = (event, value) => {\n        setNumberOfBars(value)\n        setBusy(true)\n        setArray(newShuffledArray(value, 0, barsLength))\n    }\n\n    useEffect(() => applyAnimations(getSelectedAnimations(array), animationSpeed), [numberOfBars, sortingAnimationSpeed])\n    useEffect(() => applyAnimations(getShuffleAnimations(array), animationSpeed), [array])\n    useEffect(() => applyAnimations(getAlgorithmSelectionAnimation(array), animationSpeed), [sortingAlgorithm])\n\n    const applyAnimations = (animations, speed) => {\n\n        for (let index = 0; index < animations.length; index++) {\n            setTimeout(() => {\n                let currentBars = document.getElementsByClassName('arrayBar');\n                animations[index].applyTo(currentBars)\n                if (index === animations.length - 1) setBusy(false)\n            }, index * speed);\n        }\n    }\n\n    return (\n        <Stack direction={isMobileDevice ? \"column\" : \"row\" }\n               sx={{\n                   display: 'flex',\n                   '& > *': {\n                       m: 2,\n                   }\n               }}>\n\n            <Stack sx={{\n                marginRight: 1,\n                width: stackWidth,\n                height: stackHeight\n            }}>\n\n                <FunctionsButtons isBusy={isBusy} shuffleButtonClicked={shuffleButtonClicked.bind(this)}\n                                  sortButtonClicked={sortButtonClicked.bind(this)} height={functionButtonsHeight}/>\n\n                <AlgorithmSelector isBusy={isBusy} stackWidth={stackWidth} height={height}\n                                   bubbleSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.bubbleSort); setBusy(true)}}\n                                   radixSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.radixSort); setBusy(true)}}\n                                   mergeSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.mergeSort); setBusy(true)}}\n                                   quickSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.quickSort); setBusy(true)}}\n                                   selectionSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.selectionSort); setBusy(true)}}\n                                   insertionSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.insertionSort); setBusy(true)}}\n                                   heapSortButtonClicked={() => {setSortingAlgorithm(SortingAlgorithm.heapSort); setBusy(true)}}/>\n\n                <SliderAnimationSpeed isBusy={isBusy} sliderWidth={stackWidth}\n                                      handleSpeedSlider={handleSpeedSlider.bind(this)}\n                                      maxSliderSpeedValue={ANIMATION_SPEED_SLIDER_MAX}\n                                      minSliderSpeedValue={ANIMATION_SPEED_SLIDER_MAX / 2}\n                                      defaultSpeedValue={ANIMATION_SPEED_SLIDER_MAX - defaultAnimationSpeed}\n                                      height={slidersHeight} marginTop={functionButtonsHeight + algorithmBoxHeight}/>\n\n                <SliderNumberBars isBusy={isBusy} sliderWidth={stackWidth}\n                                  handlerBarsNumberSlider={handleBarsNumberSlider.bind(this)}\n                                  maxNumberBars={canvasHeight / barsHeight}\n                                  minNumberBars={canvasHeight * 0.5 / barsHeight}\n                                  defaultNumberBars={defaultNumberOfBars}/>\n\n            </Stack>\n\n            <SortingVisualiser barsHeight={barsHeight} array={array}\n                               width={width} height={height} canvasWidth={canvasWidth}/>\n            <InformationBox algorithm={sortingAlgorithm} width={stackWidth}/>\n        </Stack>\n\n    );\n}","import {Box, Modal, Slide, Stack, Typography} from \"@mui/material\";\nimport Button from \"@mui/material/Button\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\n\nexport const FunctionButtonTutorial = ({display, close}) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\" style={explanationBoxStyle}\n                   sx={{marginTop: 2}}>\n                <Typography sx={textStyleTutorial}>These are the controllers to either shuffle all the bars or sort them\n                    given an algorithm\n                </Typography>\n                <Button sx={buttonStyleTutorial}  onClick={close}> NEXT </Button>\n            </Stack>\n        </Modal>\n    )\n}","import {Box, Modal, Stack, Typography} from \"@mui/material\";\nimport Button from \"@mui/material/Button\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\nexport const AlgorithmSelectorExplanation = ({display, close, padding, height, marginTop}) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\" style={explanationBoxStyle}\n                   sx={{\n                       marginTop: marginTop / 4.5,\n                   }}>\n                <Typography sx={textStyleTutorial}> Here one selects the algorithm that will be used to sort the bars (sorting done in\n                    ascending order)\n                </Typography>\n                <Button sx={buttonStyleTutorial}  onClick={close}> NEXT </Button>\n            </Stack>\n        </Modal>\n    )\n}","import {Modal, Stack, Typography} from \"@mui/material\";\nimport Button from \"@mui/material/Button\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\nexport const SlidersExplanation = ({display, close, padding, height, marginTop}) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\" style={explanationBoxStyle}\n                   sx={{\n                       marginTop: marginTop / 4.5\n                   }}>\n                <Typography sx={textStyleTutorial}>\n                    These are the sliders to either control the animation speed or the number\n                    of bars (bubble sort recommended fewest bars greatest speed)\n                </Typography>\n                <Button sx={buttonStyleTutorial}  onClick={close}> NEXT </Button>\n            </Stack>\n        </Modal>\n    )\n}\n","import {Modal, Stack, Typography} from \"@mui/material\";\nimport Button from \"@mui/material/Button\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\nexport const InformationBoxExplanation = ({display, close, width}) => {\n    return (\n\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"column\" style={{\n                marginTop: 20,\n                backgroundColor: \"#ff8181\",\n                width: width,\n                float: \"right\",\n                marginRight: 40,\n                color: \"white\",\n                padding: 17,\n            }}>\n                <Typography sx={{fontWeight: 'bold'}}>\n                    Here we have a small explanation of how the algorithm works, as well\n                    its complexity\n                </Typography>\n                <Button sx={buttonStyleTutorial} onClick={close}> LET'S PLAY </Button>\n            </Stack>\n        </Modal>\n    )\n}\n","import React, {useEffect, useState} from \"react\";\nimport {FunctionButtonTutorial} from \"./FunctionButtonTutorial\";\nimport {AlgorithmSelectorExplanation} from \"./AlgorithmSelectorExplanation\";\nimport {SlidersExplanation} from \"./SlidersExplanation\";\nimport {InformationBoxExplanation} from \"./InformationBoxExplanation\";\n\n\n/**\n * We define the style of each composing element of the tutorial\n * **/\nexport const buttonStyleTutorial = {\n    color: '#fff',\n    margin: 2,\n    '&:hover': {\n        backgroundColor: '#fff',\n        color: '#f38d8d',\n    },\n}\n\nexport const textStyleTutorial = {\n    padding: 2,\n    color: \"white\",\n    fontWeight: \"bold\"\n}\n\nexport const explanationBoxStyle = {\n    backgroundColor: \"#ff8181\",\n    width: 470,\n    \"margin-left\": 280\n}\n\n\n/**\n * Designed to encapsulate the functionality of the tutorial, it maintains an array with the order the\n * tutorial explains all the UI components, and each corresponding tutorial component diplays itself\n * when the current counter points to him. On close each tutorial component calls the next which updates\n * the current step of the tutorial.\n * **/\n\nexport const Tutorial = ({start, stackWidth, functionButtonsHeight, stackTopLeftMargin}) => {\n\n    const [current, setCurrent] = useState(0);\n    const tutorialSteps = ['none', 'functionButtons', 'algorithmButtons', 'slidersButtons', 'informationBox']\n\n    useEffect(() => {\n        setCurrent(start ? 1 : 0)\n    }, [start])\n\n    const next = () => {\n        setCurrent(prev => prev + 1)\n    }\n\n    return (\n        <>\n            <FunctionButtonTutorial close={next} display={tutorialSteps[current] === 'functionButtons'}\n                                    padding={stackWidth}\n                                    height={functionButtonsHeight} controllersLeftTopMargin={stackTopLeftMargin}/>\n\n            <AlgorithmSelectorExplanation height={functionButtonsHeight * 3} marginTop={functionButtonsHeight}\n                                          display={tutorialSteps[current] === 'algorithmButtons'}\n                                          padding={stackWidth} close={next}/>\n\n            <SlidersExplanation close={next} display={tutorialSteps[current] === 'slidersButtons'}\n                                paddingLeft={stackWidth}\n                                height={functionButtonsHeight} marginTop={functionButtonsHeight * 5}/>\n\n            <InformationBoxExplanation width={stackWidth}\n                                       display={tutorialSteps[current] === \"informationBox\"} close={next}/>\n        </>\n    );\n}","import {useWindowSize} from \"react-use\";\nimport {useState} from \"react\";\nimport {WelcomeGuide} from \"./visualiser/components/Welcome\";\nimport {App} from \"./App\";\nimport {Tutorial} from \"./visualiser/components/tutorial/Tutorial\";\n\n/**\n * This component is centered mainly on managing the UI dimensions positions of the elements\n * (it separates this functionality so that App, which actually provides functionality\n * is not cluttered with all this information)\n **/\n\nexport const MainApp = () => {\n    const {height, width} = useWindowSize();\n\n    /////Tutorial\n    const [welcome, showWelcome] = useState(true);\n    const [startTutorial, setStartTutorial] = useState(false)\n\n    ///Responsive constant\n    const mobileWidth = 1000\n    const isMobileDevice = mobileWidth > width\n\n    /////Dimensions\n    const stackWidth = width < mobileWidth ? width * 0.8 : width * 0.15\n    const functionButtonsHeight = 65\n\n    return (\n        <>\n            <WelcomeGuide startTutorial={() => {setStartTutorial(true); showWelcome(false)}}\n                          close={() => showWelcome(() => false)}\n                          display={welcome} width={width} height={height}/>\n\n            <Tutorial start={startTutorial} stackWidth={stackWidth} functionButtonsHeight={functionButtonsHeight}/>\n\n            <App width={width} height={height} canvasHeight={height * 0.8} canvasWidth={width * 0.8}\n                 stackWidth={stackWidth} stackHeight={height * 0.8}\n                 functionButtonsHeight={functionButtonsHeight} isMobileDevice={isMobileDevice}/>\n        </>\n    )\n\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './others/index.css';\nimport {MainApp} from './MainApp';\n\nReactDOM.render(\n  <React.StrictMode>\n      <MainApp />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}